---
layout: blog
category: 计算机
tags: 面试
---



# 互联网面试题目

## 基础知识

### 操作系统

1. 读写锁，不同点，应用场景 

   锁是线程同步的一个一个重要工具，操作系统包含了许多不同的锁，分别有

   - 信号量

     信号量分为二元信号量和多元信号量，所谓二元信号量就是指该信号量只有两个状态，要么被占用，要么空闲；而多元信号量则允许同时被N个线程占有，超出N个外的占用请求将被阻塞。信号量是“系统级别”的，即同一个信号量可以被不同的进程访问。

   - 互斥量

     和二元信号量类似， 唯一不同的是，互斥量的获取和释放必须是在同一个线程中进行的。如果一个线程去释放一个并不是它所占有的互斥量是无效的。而信号量是可以由其它线程进行释放的。

   - 临界区

     术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区是“进程级别”的，即它只在本进程的所有线程中可见，其它性质与互斥量相同（即谁获取，谁释放）

   - 读写锁

     适用于一个特定的场合。比如对于一段线程间访问的数据，如果程序大部分时间都是在读取，而只有很少的时间才会写入，那么使用前面几种锁时，每次读取也是同样 要申请锁的，而这时其它的线程就无法再对此段数据进行读取。可是，多个线程同时对一段数据进行读取时，是不存在同步问题的，那么这些读取时设置的锁就影响 了程序的性能。读写锁的出现就是为了解决这个问题的。对于一个读写锁，有两种获取方式：共享（Shared）或独占 （Exclusive）。如果当前读写锁处于空闲状态，那么当多个线程同时以共享方式访问该读写锁时，都可以成功；而此时如果一个线程以独占的方式访问该读写锁，那么它会等待所有共享访问都结束后才可以成功。在读写锁被独占访问的过程中，再次共享和独占请求访问该锁，都会进行等待状态。

   - 条件变量

     条件变量相当于一种通知机制。多个线程可以设置等待该条件变量，而一旦另外的线程设置了该条件变量（相当于唤醒条件变量）后，多个等待的线程就可以继续执行了。

2. 线程和进程的区别是什么 

   参考[线程和进程的区别](https://www.cnblogs.com/guoyu1/p/12161414.html)

   - 进程：进程是程序执行的实体，进程在操作系统中可以独立运行，作为资源分配的基本单位。表示运行中的程序
   - 线程：线程是进程中的一个实例，作为系统调度的基本单位。是进程中的一段序列，能够完成进程中的一个功能
   - 区别：
     - 同一个进程可以包含多个线程，一个进程至少包含一个线程，一个线程只能存在于一个进程中
     - 同一个进程下的所有线程共享该进程下的资源。（系统运行时会为每个进程分配不同的内存区域，即每个进程有自己的地址空间，但不会为线程分配内存，线程只能共享它所属进程的资源）
     - 进程结束后，该进程下的所有线程将被销毁，而一个线程的结束不会影响同一进程下的其他线程。
     - 线程是轻量级的进程，它的常见和销毁所需要的时间比进程小得多，所有操作系统的执行功能都是通过创建线程去完成的。
     - 线程在执行时是同步和互斥的，因为它们共享同一个进程下的资源
     - 在操作系统中，进程是拥有系统资源的独立单元，它可以拥有的自己的资源。一般而言，线程不能拥有自己的资源，但是他能够访问其隶属进程的资源。

3. 什么是死锁，死锁的条件 

   - 死锁

   就进程层面而言，死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，他们都将无法再向前推进。 举个例子而言，假设有两个线程，线程A和线程B，有两个资源，资源a和资源b。线程A现在拥有资源a，正在请求资源b；线程B拥有资源b，正在请求a资源。由于进程a,b资源均被进程暂用，所以A，B进程均会陷入等待，并且不会释放各自占有的资源，导致A，B进程一致处于等待状态，无法向前推进。

   - 死锁的四个条件

   1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
   2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
   3. 不可剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
   4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

4. 如何预防死锁，避免死锁，死锁发生的检查 

   - 预防死锁

   1. 资源一次性分配：一次性分配所有资源，这样就不会再由请求了（破坏请求条件）
   2. 只要有一个资源得不到分配，也不给这个进程分配其他资源：（破坏保持条件）
   3. 可剥夺资源：即当进程获得了部分资源，但得不到其他资源，则释放已有的资源（破坏不可剥夺条件）
   4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

   - 避免死锁
   - 检测死锁于解除死锁

5. 堆和栈的区别以及存储模式有什么区别 

   - 参考 

     [内存分配策略中，堆和栈的区别](https://www.cnblogs.com/henuliulei/p/10961496.html)

   堆栈空间分配:

   > 栈：由操作系统自动分配释放，存放函数的参数值，局部变量的值。其操作方式类似于数据结构中的栈。
   >
   > 堆：一般又程序员释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。

   堆栈缓存方式：

   > 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
   >
   > 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

   ![image-20210420125131961](https://gitee.com/zfzdr/myimages/raw/master//imgs/20210420125132.png)

6. 程序运行时内存分配原理

   程序运行时三种内存分配策略：静态的，栈式的和堆式的

   - 静态存储分配：

     在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.

   - 栈式存储分配

     也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。

   - 堆式存储分配

     专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.

7. 内存泄漏和内存溢出 

   - 内存溢出通俗理解就是内存不够，即用户在对其数据缓冲区操作时，超过了其缓冲区的边界；尤其是对缓冲区写操作时，缓冲区的溢出很可能导致程序的异常。
   - 内存泄露是指程序中已动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费。

   

8. 多线程和多进程，以及应用场景 

   两者区别：

   - 进程是资源分配的最小单位，线程是系统调度和分配的基本单位
   - 属于同一进程的线程，堆是共享的，栈是私有的
   - 属于同一进程的所有线程都具有相同的地址空间

   多进程的优点：

   - 编程相对容易，通常不需要考虑锁和同步资源的问题
   - 更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程
   - 又内核保证的隔离：数据和错误隔离。多余使用如C/C++这些语言编写的本地代码，错误隔离式非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）

   多线程的优点：

   - 创建速度快，方便高效的数据共享

     共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。

   - 较轻的上下文切换开销-不用切换地址空间，不用更改寄存器，不用刷新TLB

   - 提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。

   多进程应用场景：

   - nginx主流的工作模式是多进程模式
   - 几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程
   - chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）
   - redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

   多线程应用场景：

   - 线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）。
   - 提供非均质的服务（有优先级任务处理）事件响应有优先级。
   - 单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延。 
   - 与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）
   - 案例：
     桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程； 

9. 进程通信方式 

   每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

   - 管道通信

     管道，通常指无名管道，是UNIX系统IPC最古老的形式

     - 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
     - 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
     - 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

     **匿名管道通信**

     匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

     步骤：

     1. 父进程创建管道，得到两个文件描述符指向管道的两端
     2. 父进程fork出子进程，子进程也有两个文件描述符指向同一管道
     3. 父进程关闭fd[0],子进程关闭fd[1],即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。

     **高级管道通信**

     高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

     **命名管道**

     和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问，而无名管道却不同，进程只能访问自己或祖先创建的管道，而不能访任意访问已经存在的管道——因为没有名字。

   - 消息队列

     消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以从消息队列读取消息。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。

   - 共享内存

     共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。

   - 信号量

     信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

     1、特点
     信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。

     信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

     每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。

     支持信号量组。

10. 多线程如何实现的 

    - 线程安全

      当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。

    - 

11. 计算机内存管理的方式 

    - 段式管理
    - 页式管理
    - 段页式管理

12. 进程调度方法 

    - 先到先服务(FCFS)
    - 短作业优先（SJF）
    - 时间片轮转
    - 多继反馈队列调度算法
    - 优先级调度

13. 什么是Linux用户态和内核态 

    Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。

14. 进程的状态，进程状态就绪和等待状态的区别是什么 

    - 创建状态
    - 就绪状态
    - 运行状态
    - 阻塞状态
    - 结束状态

15. 虚拟内存是干嘛的 

16. 线程池 

17. 线程安全的实现方式 

18. 进程和线程的上下文切换 

19. 协程

### 计算机网络

1. TCP三次握手，四次挥手的过程 
2.  为什么[客户端]()要在TIME_WAIT状态等待一段时间 
3.  CLOSING状态 
4.  如果server端没有收到第三次ack，但是收到了client端发送的数据，server端会怎么处理 
5.  讲一讲get和post 
6.  http状态码 
7.  TCP和UDP 
8.  一次HTTP请求的过程（输入URL到返回的全过程） 
9.  http和https 

1.  无状态和无连接 
2.  OSI七层模型，各层有哪些协议 

1.  HTTP协议 请求报文结构 

1.  TCP如何保证可靠传输，丢包怎么办 
2.  讲一下滑动窗口 
3.  TCP三次握手中SYN和ACK包有什么不同，包含什么 
4.  UDP想要可靠怎么实现 RUDP 
5.  半连接攻击 
6.  TCP粘包和拆包 
7.  cookie和session是什么，为什么要用cookie和session 
8.  DNS协议和作用 
9.  DNS的查询方式 
10.  ARP协议作用、工作方式 
11.  以太网数据包的大小最大为多少 
12.  三次握手过程中是否存在安全问题？描述一下存在什么样的安全问题？针对这样的安全问题如何防御？ 
13.  web攻击，CSRF攻击 
14.  TCP如何进行拥塞控制？拥塞控制如何判断发生拥塞？ 
15.  TCP快重传如何判断丢失？ 
16.  https证书在哪存放 
17.  长连接和短连接以及他们分别适用的场景

### 数据库

1. sql语句

   - 取一个月内的id分组 
   -  取一个年级中每个班级年龄最小的同学名字 
   - 成绩表输出前三名的成绩，后三名呢 
   - 拷贝A表的数据到B表 
   - 查询每门科目都大于80分的学生名字 
   - 筛选出每个小时的记录  
   - 考察where 
   - 考察聚合函数 
   - where和having的区别 
   - 一个数据库sql查询重复个数 
   - 在学生成绩表中查询平均分不及格（低于60）的学生id及平均分 
   - 查询总成绩最高的人的姓名 
   - user表中在一个时间段内登陆三次的用户id 
   - limit的用法

2. 数据库引擎及他们之间的区别 

   - InnoDB 

   - MyISAM 

   - MEMORY 

3.  mysql的日志怎么查询 

4.  （多次）查询速度慢的原因，如何解决 

5.  数据库的事务是什么？怎么使用 

6.  主键、外键、索引的各自的含义以及区别 

7.  事务的特性（ACID），讲一下每个特性的意思 

8.  索引的类型 

9.  什么是聚簇索引、什么是非聚簇索引 

10.  索引的数据结构是什么 

11.  前缀索引 

12.  MySQL/MongoDb 端口号 

13.  数据库有几种表之间的连接形式（左连接，右连接，内连接，完全连接） 

14.  说说[redis]()中的数据结构和应用场景 

15.  三大范式 

16.  数据库隔离等级 

17.  为什么要用b+树索引而不用hash

## 语言

### python

1. python的内存池机制 
2.  python数组和列表的区别 
3.  python你常用哪些包，标准库 
4.  面向过程和面向对象的语言区别 
5.  反射 
6.  python的数据结构 
7.  dict和list的底层实现 
8.  python装饰器，作用，用法 
9. 编译型语言和解释型语言 解释型语言的优点 
10.  垃圾回收机制 
11.  GIL锁 
12.  is和== 
13.  __new__和__init__区别 
14.  用python写出多线程，循环打印123

## linux

1. 常见命令 
   - 查看进程ps 查看所有进程长格式ps -ef 
   -  打印当前文件夹文件 ls -al a所有文件 l详细信息 
   -  软链接 ln -s a target 硬链接 ln 
   -  创建目录 mkdir 
   -  修改权限 chmod 
   -  查看文件： 
   -  移动文件mv 也可以重命名 
   -  复制文件cp 
   -  删除文件 rm -r 递归删除 -f删除只读文件 
   -  通配符？单个字符，*多个字符，[a-z]字符集 
   -  grep 正则搜索 显示行号-n 查询个数-c 反选-v 
   -  查看指定进程 ps -ef | grep pid 
   -  查看命令历史 history 
   -  查看磁盘空间df -hl 
   -  查看文件大小du 
   -  查找文件 find [目录] 以名字查找-name “h*”以h开头 
   -  终止一个进程 kill -9 pid 
2. 如何防止新人误操作rm -rf   
3. 找进程号为199的进程 ls -ef|grep 199   
4. 某文件中含关键词的行数 grep -c "key" ./file 
5. 该目录下以.log结尾的文件中包含关键词a但不包含关键词b的行数 grep "a" ./file | grep -cv "b"